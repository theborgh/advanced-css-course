/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/* Use universal selector for browse */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Font-family is best set in body to take advantage of inheritance, it's more efficient than using it in the universal selector */
body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  font-size: 16px;
  line-height: 1.7; /* 1.7 times the predifined line height */
  color: #777;
  padding: 30px;
}

.header {
  height: 95vh;
  background-image: linear-gradient(
    to right bottom,
    rgba(126, 213, 111, 0.8),
    rgba(40, 180, 131, 0.8)),
    url('../img/hero.jpg'); /* background-image is used to specify gradients. This syntax is to display both the image and the gradient at the same time */
  background-size: cover; /* Fit the element to the width of its container */
  background-position: top; /* The top of the img stays at the top of the container, the bottom might get cropped. Center => crop at top and bottom evenly */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0% 100%); /* To clip out part of the image, use polygon to specify the coordinates you want to keep VISIBLE starting from top left, top right, bottom right, bottom left. You can draw ANY POLYGON with this function! http://bennetfeely.com/clippy/ for shapes */
  position: relative;
}

.logo-box {
  position: absolute;
  top: 40px; /* counting from a parent element with a position set to RELATIVE (header in this case! Without setting position:relative on the header, this would NOT work!) */
  left: 40px;
}

.logo {
  height: 35px; /* width will scale automatically */
}

.text-box {
  position: absolute;
  top: 40%; /* In relation to the PARENT element */
  left: 50%;
  transform: translate(-50%, -50%); /* This is relative to the element itself! Centers the MIDDLE of the element and vertically */
  text-align: center;
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  backface-visibility: hidden; /* fixes quirks at the end of an animation */
  margin-bottom: 60px;
}

/* block elements occupy the entire width available in the parent and create line breaks before and after them */
.heading-primary-main {
  display: block;
  font-size: 60px;
  font-weight: 400;
  letter-spacing: 35px;

  animation-name: moveInLeft;
  animation-duration: 3s;
  animation-timing-function: ease-out; /* How the parameters change over time */

  /* animation-iteration-count: 3;
  animation-delay: 1s; */
}

.heading-primary-sub {
  display: block;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: 17.4px;

  animation-name: moveInRight;
  animation-duration: 3s;
  animation-timing-function: ease-out;
}

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-100px);
  }

  80% {
    transform: translateX(10px);
  }

  100% {
    opacity: 1;
    transform: translate(0px);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(100px);
  }

  80% {
    transform: translateX(-10px);
  }

  100% {
    opacity: 1;
    transform: translate(0px);
  }
}

@keyframes moveInButton {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }

  100% {
    opacity: 1;
    transform: translate(0px);
  }
}

.btn-animated {
  animation-name: moveInButton;
  animation-duration: 1s;
  animation-delay: 0.75s;
  animation-fill-mode: backwards; /* Applies the animation keyframe at 0% before the animation starts! */
}

.btn:link,
.btn:visited { /* selects the link pseudoclass. Link is a special state of a selector, when it functions as a link. Visited is for after the link was clicked */
  text-transform: uppercase;
  text-decoration: none;
  padding: 15px 40px; /* 1 value => everywhere, 2 => top+bottom, left+right, 4 => top, right, bottom, left  */
  display: inline-block; /* make it a block element so that padding gets applied correctly. Inline-block is treated as text */
  border-radius: 100px; /* Can overshoot, same result */
  transition: all 0.2s; /* which properties do I want to animate? */
  position: relative; /* making the ::after element work (it's absolute) */
}

.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2); /* params: offsetX, offsetY, blur, color */
}

.btn:active { /* Active: while being clicked */
  transform: translateY(-1px);
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
}

.btn-white {
  background-color: white;
  color: #777;
}

.btn::after { /* adds a virtual element right after the element I'm selecting. Adds an element exactly like what I already have, but put it behind the button, and when I hover out of the buttom the pseudo element goes back behind the button. */
  content: ""; /* must be specified */
  display: inline-block;
  height: 100%; /*  The ::after pseudo element is treaded like a child of the button */
  width: 100%;
  border-radius: 100px;
  position: absolute; /* puts it behind the button */
  top: 0;
  left: 0;
  z-index: -1; /* behind */

  transition: all 0.4s; /* transitions go on the INITIAL state */
}

.btn-white::after {
  background-color: white;
}

.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6);
  opacity: 0;
}